<!DOCTYPE HTML>
<html lang="ko" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>IamCoder Wiki</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="IamCoder Wiki">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">사이트 소개</a></li><li class="chapter-item expanded affix "><a href="what-is-iamcoder.html">IamCoder란?</a></li><li class="spacer"></li><li class="chapter-item expanded "><strong aria-hidden="true">1.</strong> 알고리즘</li><li><ol class="section"><li class="chapter-item expanded "><a href="algorithm/sort/sort.html"><strong aria-hidden="true">1.1.</strong> Sort</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="algorithm/sort/bubblesort.html"><strong aria-hidden="true">1.1.1.</strong> Bubble Sort</a></li><li class="chapter-item expanded "><a href="algorithm/sort/selectionsort.html"><strong aria-hidden="true">1.1.2.</strong> Selection Sort</a></li><li class="chapter-item expanded "><a href="algorithm/sort/insertionsort.html"><strong aria-hidden="true">1.1.3.</strong> Insertion Sort</a></li><li class="chapter-item expanded "><a href="algorithm/sort/mergesort.html"><strong aria-hidden="true">1.1.4.</strong> Merge Sort</a></li><li class="chapter-item expanded "><a href="algorithm/sort/heapsort.html"><strong aria-hidden="true">1.1.5.</strong> Heap Sort</a></li><li class="chapter-item expanded "><a href="algorithm/sort/quicksort.html"><strong aria-hidden="true">1.1.6.</strong> Quick Sort</a></li><li class="chapter-item expanded "><a href="algorithm/sort/countingsort.html"><strong aria-hidden="true">1.1.7.</strong> Counting Sort</a></li><li class="chapter-item expanded "><a href="algorithm/sort/radixsort.html"><strong aria-hidden="true">1.1.8.</strong> Radix Sort</a></li><li class="chapter-item expanded "><a href="algorithm/sort/introsort.html"><strong aria-hidden="true">1.1.9.</strong> Intro Sort</a></li></ol></li><li class="chapter-item expanded "><strong aria-hidden="true">1.2.</strong> Graph Traverse</li><li class="chapter-item expanded "><a href="algorithm/divideandconquer/divideandconquer.html"><strong aria-hidden="true">1.3.</strong> Divide &amp; Conquer</a></li><li class="chapter-item expanded "><strong aria-hidden="true">1.4.</strong> Dynamic Programming</li><li class="chapter-item expanded "><strong aria-hidden="true">1.5.</strong> Shortest Path</li><li class="chapter-item expanded "><strong aria-hidden="true">1.6.</strong> Query Technique</li><li class="chapter-item expanded "><strong aria-hidden="true">1.7.</strong> DP Optimization</li><li class="chapter-item expanded "><strong aria-hidden="true">1.8.</strong> Network Flow</li><li class="chapter-item expanded "><strong aria-hidden="true">1.9.</strong> Geometry</li><li class="chapter-item expanded "><strong aria-hidden="true">1.10.</strong> String</li></ol></li><li class="chapter-item expanded "><strong aria-hidden="true">2.</strong> 자료구조</li><li><ol class="section"><li class="chapter-item expanded "><strong aria-hidden="true">2.1.</strong> Basic</li><li class="chapter-item expanded "><strong aria-hidden="true">2.2.</strong> Intermediate</li><li class="chapter-item expanded "><strong aria-hidden="true">2.3.</strong> Tree</li><li class="chapter-item expanded "><strong aria-hidden="true">2.4.</strong> Segment Tree</li><li class="chapter-item expanded "><strong aria-hidden="true">2.5.</strong> Advanced</li></ol></li><li class="chapter-item expanded "><strong aria-hidden="true">3.</strong> 기타</li><li><ol class="section"><li class="chapter-item expanded "><strong aria-hidden="true">3.1.</strong> Additional Topics</li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">IamCoder Wiki</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/iamcoder-wiki/iamcoder-wiki.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#iamcoder-wiki" id="iamcoder-wiki">IamCoder Wiki</a></h1>
<p>안녕하세요. 나코더(나는코더다) 위키입니다.</p>
<h1><a class="header" href="#iamcoder" id="iamcoder">IamCoder</a></h1>
<h1><a class="header" href="#sort" id="sort">Sort</a></h1>
<h2><a class="header" href="#sort정렬이란" id="sort정렬이란">Sort(정렬)이란?</a></h2>
<p>프로그래밍에서 정렬이란 무작위로 있는 여러 자료들의 순서를 규칙성 있게 재배열하는 것을 뜻한다. 오름차순, 또는 내림차순으로 정렬하는 것이 일반적이나, 내가 임의로 정한 규칙에 따라 정렬해야 하는 경우도 있다. 정렬해야 하는 자료들의 개수가 \(n\)일 때, 정렬알고리즘은 크게 시간복잡도가 \(O(n^2)\), \(O(n\log n)\)과 그 이외인 것으로 나뉘는데, 초급단계에서는 이 \(O(n^2)\) 방법만 알아도 큰 무리는 없다. 구현이 \(5\)에서 \(6\)줄 정도로 매우 짧고 개념도 직관적으로 이해가 쉽기 때문이다. 그러나 중급단계 이상에서는 \(100000\)개 이상의 자료들을 정렬해야 하는 경우가 생겨 \(O(n^2)\)방법으로는 시간초과가 나게 된다. 따라서 \(O(nlogn)\)정렬을 기용해야 하는데, 구현이 모두 \(20\)줄 이상으로 생각보다 쉽지만은 않다. 그러나 우리에게는 하나의 무기가 있는데, 그게 뭔지는 차차 알아가 보도록 하자. 이제부터 설명을 시작할 건데, 이하의 예시코드는 다음의 함수 \(sortarr()\) 안에 들어갈 코드로 하자. \(n\)개의 \(int\)형 자료를 오름차순으로 정렬하여 순서대로 출력하는 프로그램을 다음과 같이 구현하자.</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
int arr[100010], n;
int main()  
{
    scanf(&quot;%d&quot;, &amp;n);
    for(int i=1; i&lt;=n; i++)
        scanf(&quot;%d&quot;, &amp;arr[i]);
    sortarr();  //여기
    for(int i=1; i&lt;=n; i++)
        printf(&quot;%d &quot;, arr[i]);
}
</code></pre>
<h2><a class="header" href="#-on2--sort" id="-on2--sort">\( O(n^2) \) Sort</a></h2>
<h3><a class="header" href="#종류" id="종류">종류</a></h3>
<ul>
<li><a href="algorithm/sort/./bubblesort.html">Bubble Sort</a></li>
<li><a href="algorithm/sort/./selectionsort.html">Selection Sort</a></li>
<li><a href="algorithm/sort/./insertionsort">Insertion Sort</a></li>
</ul>
<h3><a class="header" href="#여담" id="여담">여담</a></h3>
<p>이로써 기본적인 정렬 알고리즘들을 살펴보았는데, 이 알고리즘들은 정렬할 때 쓰일 뿐만 아니라 문제에도 활용이 되는 기본 중의 기본으로 꼭 익혀둬야 한다. 앞으로의 \(O(n\log n)\) 알고리즘들은 더욱 심화된 자료구조와 기법을 사용하므로 모르는 자료구조가 있으면 같은 책의 앞 또는 뒤에 설명이 있으므로 참고하면 되고, 인터넷에서도 설명이 친절하게 되어 있으니 참고하길 바란다.</p>
<h2><a class="header" href="#onlog-n-sort" id="onlog-n-sort">\(O(n\log n)\) Sort</a></h2>
<h3><a class="header" href="#종류-1" id="종류-1">종류</a></h3>
<ul>
<li><a href="algorithm/sort/./mergesort">Merge Sort</a></li>
<li><a href="algorithm/sort/./heapsort">Heap Sort</a></li>
<li><a href="algorithm/sort/./quicksort">Quick Sort</a></li>
</ul>
<h2><a class="header" href="#기타-정렬" id="기타-정렬">기타 정렬</a></h2>
<h3><a class="header" href="#종류-2" id="종류-2">종류</a></h3>
<ul>
<li><a href="algorithm/sort/./countingsort">Counting Sort</a></li>
<li><a href="algorithm/sort/./radixsort">Radix Sort</a></li>
<li><a href="algorithm/sort/./introsort">Intro Sort</a></li>
</ul>
<h2><a class="header" href="#여담-1" id="여담-1">여담</a></h2>
<h1><a class="header" href="#bubble-sort" id="bubble-sort">Bubble Sort</a></h1>
<h2><a class="header" href="#소개" id="소개">소개</a></h2>
<p>\(O(n^2)\)정렬 중에서 구현이 제일 쉽고 유명한 방법이다. 인접한 두개의 항의 대소를 비교하여 작은 것을 앞으로 보내는 방법이다. 이 방법의 정당성은 이해하기 쉽다. \((1, 2), (2, 3), … ,(n-1, n)\) 번을 순차적으로 비교했을 때, 다른 것은 모르지만 \(n\)번째 원소의 값이 최대라는 것은 확신할 수 있다. 이를 \(n\)번 반복하여 뒤에서부터 올바르게 숫자를 채워나간다면 정렬이 완료될 것이다. 이를 \(for\)문 두개를 이용하여 구현할 수 있고, 총 연산이 \(n*(n-1)/2\)번 실행되므로 시간복잡도는 \(O(n^2)\)이다.</p>
<h2><a class="header" href="#코드" id="코드">코드</a></h2>
<pre><code class="language-c++">void sortarr()
{
    for(int i=1; i&lt;n; i++)
        for(int j=1; j&lt;=n-i; j++)
            if(arr[j]&gt;arr[j+1])
                swap(arr[j], arr[j+1]);
}
</code></pre>
<h3><a class="header" href="#" id=""></a></h3>
<h1><a class="header" href="#selection-sort" id="selection-sort">Selection Sort</a></h1>
<h2><a class="header" href="#소개-1" id="소개-1">소개</a></h2>
<p>오히려 삽입정렬보다 개념을 이해하기는 더 쉬울지도 모르겠다. \(1\)번 원소부터 \(n\)개의 원소를 다 둘러보면서 최솟값을 찾은 뒤, 그 값을 원래 \(1\)번원소와 바꾸고, \(2\)번 원소부터 \(n\)번원소까지 이를 반복하는 것이다. 긴말없이 코드로 보여주도록 하겠다.</p>
<h2><a class="header" href="#코드-1" id="코드-1">코드</a></h2>
<pre><code class="language-c++">void sortarr()
{
    int minnum;
    for(int i=1; i&lt;n; i++){
        minnum=i;
        for(int j=i+1; j&lt;=n; j++)
            if(arr[j]&lt;arr[minnum])
                minnum=j;
        swap(arr[i], arr[minnum]);
    }
}
</code></pre>
<h1><a class="header" href="#insertion-sort" id="insertion-sort">Insertion Sort</a></h1>
<h2><a class="header" href="#소개-2" id="소개-2">소개</a></h2>
<p>\(O(n^2)\)중에서는 개념적으로는 선택정렬까지는 아니지만 버블정렬보다는 쉽지만, 사실 잘 쓰지 않는 정렬 기법이다. \(1\)번부터 \(n\)번의 단계가 있는데, \(i\)번째 단계에서는 \(1\)번부터 \(i-1\)번째원소까지 모두 정렬되어 있는 상황에서 \(1\)번부터 \(i\)번까지 정렬한다. \(1\)번부터 \(i-1\)번까지 정렬되어 있으니, 그냥 뒤에서부터 훑어보면서 이 숫자가 들어갈 곳을 찾으면 된다.</p>
<h2><a class="header" href="#코드-2" id="코드-2">코드</a></h2>
<pre><code class="language-c++">void sortarr()
{
    for(int i=1; i&lt;=n; i++){
        int key=arr[i];
        for(int j=i-1; j&gt;=1; j--){
            if(key&gt;arr[j]){
                arr[j+1]=key;
                break;
            }
            swap(arr[j], arr[j+1]);
        }
    }
}
</code></pre>
<h1><a class="header" href="#merge-sort" id="merge-sort">Merge Sort</a></h1>
<h2><a class="header" href="#소개-3" id="소개-3">소개</a></h2>
<p>병합정렬은 분할정복, 혹은 \(D&amp;C(Divide &amp; Conquer)\)을 사용한 알고리즘으로, 폰 노이만이 개발했다고 한다. 병합정렬의 아이디어는 어떤 배열을 두 조각으로 자르는 거에서 시작한다. 만약 두 조각으로 자른 것들이 이미 정렬되어 있다고 하면, 두 조각을 합쳐서 원래 배열을 정렬시키는 데에는 \(O(n)\)의 시간복잡도밖에 걸리지 않는다. 어떻게 하느냐면, \(“3, 6, 8, 9”\)와 \(“1, 4, 7, 10”\)을 합칠 때(병합할 때) 두 배열에 대한 피벗을 각각 잡아 피벗들끼리 비교하여 더 작은 것부터 원래 배열에 담는 것이다. 즉 이 경우 \(3\)과 \(1\), \(3\)과 \(4\), \(6\)과 \(4\), \(6\)과 \(7\), \(8\)과 \(7\), \(8\)과 \(10\), \(9\)와 \(10\)을 순서대로 비교하여 새 배열에는 \(“1, 3, 4, 6, 7, 8, 9, 10”\)이 들어가게 된다. 그렇다면, 이를 재귀적으로 계속 절반씩 나눠가면서 각 배열의 절반씩을 정렬하면 될 것이다. 그런데, \(n\)을 계속 절반으로 쪼개나가는 것이니 재귀탐색은 깊어봤자 \(\log n\)번씩 밖에 실행되지 않을 것이다! 따라서 전체 알고리즘은 \(O(n\log n)\)안에 실행될 것이다. \(main\)함수의 \(arrsort()\)를 \(mergesort(1, n)\)으로 바꾸고 구현한 병합정렬의 코드이다.</p>
<h2><a class="header" href="#코드-3" id="코드-3">코드</a></h2>
<pre><code class="language-c++">void mergesort(int st, int fin)
{
    if(st&gt;=fin)return;
    int mid=(st+fin)/2;
    mergesort(st, mid);
    mergesort(mid+1, fin);
    int pv1=st, pv2=mid+1, merged[100010], re=st;
    while(pv1&lt;=mid||pv2&lt;=fin){
        if(pv1&gt;mid)merged[re++]=arr[pv2++];
        else if(pv2&gt;fin)merged[re++]=arr[pv1++];
        else merged[re++]=arr[pv1]&lt;=arr[pv2]?arr[pv1++]:arr[pv2++];
    }
    for(int i=st; i&lt;=fin; i++){
        arr[i]=merged[i];
    }
}
</code></pre>
<h1><a class="header" href="#heap-sort" id="heap-sort">Heap Sort</a></h1>
<h2><a class="header" href="#소개-4" id="소개-4">소개</a></h2>
<p>우선 힙이라는 자료구조를 안다는 가정하에 설명을 시작하도록 하겠다. 우리는 최소 힙을 이용해 선택정렬의 방법을 최적화할 것이다. 선택정렬에서 어떤 구간의 최솟값을 찾는데 그것을 찾기 위해 \(n\)개의 칸을 탐색하던지, 힙을 이용하는지의 차이이다. 힙에서는 원소를 추가하는데 \(\log n\), 삭제하는데 \(\log n\)의 시간복잡도가 필요한 반면, 힙의 최소 혹은 최댓값은 상수시간 안에 구해낼 수 있어 이를 이용해 구현한 힙정렬은 \(O(n\log n)\)의 시간복잡도를 가진다. \(main\)함수의 \(sortarr()\)을 \(heapsort()\)로 바꾼 뒤 작성한 코드이다.</p>
<h2><a class="header" href="#코드-4" id="코드-4">코드</a></h2>
<h5><a class="header" href="#heap-sort-without-priority_queue" id="heap-sort-without-priority_queue">Heap Sort without priority_queue</a></h5>
<pre><code class="language-c++">void in_heap(int num)
{
    heap[++siz]=num;
    int temp=siz;
    while(temp&gt;1){
        if(heap[temp/2]&gt;heap[temp])swap(heap[temp/2], heap[temp]);
        else break;
        temp/=2;
    }
}
void poptop_heap()
{
    swap(heap[1], heap[siz]);
    heap[siz]=987654321;
    siz--;
    int temp=1;
    while(temp&lt;=siz/2){
        if(heap[temp]&lt;=heap[temp*2]&amp;&amp;heap[temp]&lt;=heap[temp*2+1])break;
        if(heap[temp*2]&lt;=heap[temp*2+1]){
            swap(heap[temp], heap[temp*2]);
            temp*=2;
        }
        else{
            swap(heap[temp], heap[temp*2+1]);
            temp*=2;
            temp++;
        }
    }
}
void heapsort()
{
    for(int i=1; i&lt;=n; i++)
        in_heap(arr[i]);
    for(int i=1; i&lt;=n; i++){
        arr[i]=heap[1];
        poptop_heap();
    }
}
</code></pre>
<h5><a class="header" href="#heap-sort-using-priority_queue" id="heap-sort-using-priority_queue">Heap Sort using priority_queue</a></h5>
<p>힙이란 자료구조는 이미 우선순위 큐의 형태로 구현되어 있으므로 이를 이용하면 코드가 훨씬 간결해진다. 다만 우선순위 큐는 최대 힙으로 원래 수에 \(-1\)을 곱해준 값으로 우선순위 큐 안에 넣어주게 되면 최소 힙처럼 사용할 수 있다.</p>
<pre><code class="language-c++">void heapsort()
{
    priority_queue&lt;int&gt; pq;
    for(int i=1; i&lt;=n; i++)
        pq.push(-arr[i]);
    for(int i=1; i&lt;=n; i++){
        arr[i]=-pq.top();
        pq.pop();
    }
}
</code></pre>
<h1><a class="header" href="#quick-sort" id="quick-sort">Quick Sort</a></h1>
<h2><a class="header" href="#소개-5" id="소개-5">소개</a></h2>
<p>퀵정렬은 다른 알고리즘과는 다르게 시간복잡도가 딱히 정해져 있지 않다. 그 이유는 시간복잡도가 \(n\)이 아닌 입력된 배열에 의존하기 때문이다. 퀵정렬은 분할정복을 기본으로 하는데, 어느 하나의 랜덤한 값을 잡아 그보다 작은 값들은 앞으로, 큰 값을 뒤로 몰아놓은 뒤 두 부분을 각각 재귀적으로 정렬해주는 것이다. 시간복잡도는 이때 랜덤하게 잡은 값에 의존하는데, 모든 과정에서 이 랜덤값이 중앙값이면, 시간복잡도는 \(O(nlogn)\)이 되고, 모든 과정에서 랜덤값이 최소이거나 최대이면 시간복잡도가 \(O(n^2)\)이다. 그런데 사실 이럴 일은 매우 드물기 때문에, 안심하고 써도 문제는 없다. \(main\)함수의 \(arrsort()\)를 \(quicksort(1, n)\)으로 바꾸자. 우리는 이 랜덤한 값을 그냥 정렬하는 수들 중 마지막 수로 하자. 실전에서는 이 랜덤한 값을 난수로 처리하거나, 정렬하는 수들중의 중앙값을 이용한다.</p>
<h2><a class="header" href="#코드-5" id="코드-5">코드</a></h2>
<pre><code class="language-c++">void quicksort(int st, int fin)
{
    if(st&gt;=fin)return;
    int temp[100010], fr=st, re=fin-1;
    for(int i=st; i&lt;fin; i++){
        if(arr[i]&lt;=arr[fin])temp[fr++]=arr[i];
        else temp[re--]=arr[i];
    }
    for(int i=st; i&lt;fin; i++)
        arr[i]=temp[i];
    swap(arr[fr], arr[fin]);
    quicksort(st, re);
    quicksort(fr, fin);
}
</code></pre>
<h1><a class="header" href="#counting-sort" id="counting-sort">Counting Sort</a></h1>
<h2><a class="header" href="#소개-6" id="소개-6">소개</a></h2>
<p>정렬하는 수들의 크기가 그리 크지 않고, 모두 0이상일 때 쓰는 정렬인데, 다른 정렬들과 달리 메모리가 굉장히 많이 필요하다. 그러나 수들이 전부 많이 작으면 이보다 빠른 정렬은 없을 것이다. 시간복잡도가 무려 \(O(n+max(arr[i]))\)로, 배열값만 적당하다면 선형시간 안에 정렬을 할수 있기 때문이다. 정렬의 이름답게 각 원소의 개수를 배열에 저장해 둔 뒤 그 자료를 이용해 정렬을 하는 것이다. 다만 최댓값이 9백만 정도가 넘어가면 일반적인 문제에서 메모리 초과가 나게 되는 치명적인 단점이 있다.</p>
<h2><a class="header" href="#코드-6" id="코드-6">코드</a></h2>
<pre><code class="language-c++">void sortarr()
{
    int cnt[100010];
    fill(cnt, cnt+100005, 0);
    for(int i=1; i&lt;=n; i++)cnt[arr[i]]++;
    int num=0, pv=0;
    while(num&lt;n){
        if(!cnt[pv])pv++;
        else{
            arr[++num]=pv;
            cnt[pv]--;
        }
    }
}
</code></pre>
<h1><a class="header" href="#radix-sort" id="radix-sort">Radix Sort</a></h1>
<h2><a class="header" href="#소개-7" id="소개-7">소개</a></h2>
<p>카운팅 정렬의 약점을 완벽하게 보완해주는 정렬 방법이다. 시간복잡도의 \(d\)는 각 원소의 자릿수중 최댓값인데, 각 자리수별로 카운팅 정렬을 실행하여 정렬하여 큰 수에 대해서도 정렬을 시행할 수 있다. 물론 가장 큰 자릿수부터 정렬을 시행해 주어야 할 것이다. 래딕스 정렬은 \(Big Integer\)라 불리는 \(unsigned long long int\) 범위를 훨씬 벗어나는, \(10^100\)과 같은 수들을 정렬할 때 유용하게 쓰일 수 있다. 코드는 카운팅 정렬의 것을 약간만 수정하면 되므로 생략하도록 하겠다.</p>
<h1><a class="header" href="#intro-sort" id="intro-sort">Intro Sort</a></h1>
<h2><a class="header" href="#소개-8" id="소개-8">소개</a></h2>
<p>퀵정렬과 힙정렬을 합한 정렬이다. 기본적으로 퀵정렬을 하지만, 어느정도 재귀가 깊어지면 힙정렬을 이용해 퀵정렬에서 나올 수 있는 최악의 시간복잡도를 피해준다. </p>
<h2><a class="header" href="#stl-sort" id="stl-sort">STL sort</a></h2>
<p>하지만 이 인트로 정렬은 구현이 지금까지 나온 모든 정렬보다 쉽다! 왜냐하면, \(C++\)에서 이 인트로 정렬을 지원해주기 때문에 딱 한줄이면 정렬이 마무리 된다! 실전에서 가장 유용하게 쓰이는 함수라 봐도 무방하고, 그만큼 빠른 정렬이기에 이 단원을 읽으면서 이거 하나만은 꼭 알고 가자. \(<algorithm>\) 헤더파일에 존재하는 \(sort\)함수는 \(sort\)(시작포인터, 끝포인터, 비교함수의 포인터)의 꼴로 이루어져있는데, \(3\)번째 항을 빈칸으로 남겨둔다면 오름차순 정렬을 시행한다. </p>
<h3><a class="header" href="#비교-함수" id="비교-함수">비교 함수</a></h3>
<p>\(sort\)함수의 가장 큰 장점은 \(int\)뿐만 아니라 내가 임의로 만든 구조체라던지 \(pair\)등의 대소비교가 가능한 모든 자료구조에 대해서 적용이 가능하다는 것이다! 비교함수의 작성법에 대해 아래 코드를 보면서 설명하도록 하겠다.</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
struct data
{
    int a;
    char c;
}arr[100010];
bool comp(data x, data y)
{
    if(x.a!=y.a)return x.a&lt;y.a;
    return x.c&lt;y.c;
}
int main()
{
    int n;
    scanf(&quot;%d&quot;, &amp;n);
    for(int i=1; i&lt;=n; i++)
        scanf(&quot;%d %c&quot;, &amp;arr[i].a, &amp;arr[i].c);
    sort(arr+1, arr+n+1, comp);
    for(int i=1; i&lt;=n; i++)
        printf(&quot;%d %c\n&quot;, arr[i].a, arr[i].c);
}
</code></pre>
<p>위와 같이 코드를 작성하면, 각 구조체\(a\)값이 작은것, \(c\)값이 작은 것의 우선순위로 구조체들이 정렬된다. 즉, \(sort\)함수에 내장된 코드들이 \(comp\) 함수를 호출할때 \(x\)가 앞의 원소, \(y\)가 뒤의 원소일때 \(comp(x, y)\)가 리턴하는 값이 \(true\) 이면 바꾸지 않고 \(false\)일때 두 자리가 바뀌게 된다. 다른건 몰라도 이 \(sort\)함수의 사용법만큼은 꼭 익혀두기 바란다.</p>
<h1><a class="header" href="#divide--conquer" id="divide--conquer">Divide &amp; Conquer</a></h1>
<h2><a class="header" href="#소개-9" id="소개-9">소개</a></h2>
<p>Divide &amp; Conquer(D&amp;C) 혹은 분할 정복이라 불리는 문제 해결 기법은 최적해를 구할 때 유용하게 사용될 수 있는 기법 중 하나로, 주어진 문제를 두개 이상의 부분 문제들로 분할하고 각각을 해결한 후 이를 다시 합쳐 주어진 문제를 해결하는 방식입니다. 다시 말해, 문제를 여러개의 해결 가능한 부분 문제들로 나누고 각각을 해결한 후 이 결과를 적절히 융합하여 원래 문제의 답을 구하는 방식을 반복하여 문제를 해결하는 방법입니다. 이 방식을 사용하는 이유는 각각을 부분 문제로 분할하고 이를 각각 해결하는 방식이 다른 방식들에 비해 효율적으로 작동하는 경우가 많기 때문입니다. </p>
<h2><a class="header" href="#방법" id="방법">방법</a></h2>
<p>일반적으로 분할 정복 알고리즘의 과정을 정리하자면 다음과 같습니다.</p>
<pre><code>1) 문제가 분할이 가능하다면 2개 이상의 부분 문제들로 분할 (Divide)
2) 나뉜 문제가 추가적으로 분할이 가능할 경우 다시 분할, 그렇지 않을 경우 문제를 해결 (Conquer)
3) 아래 단계에서 Conquer 과정을 통해 답을 구한 부분 문제들을 다시 합하여 원래 문제의 답을 구함
</code></pre>
<h2><a class="header" href="#예시" id="예시">예시</a></h2>
<p>분할 정복 알고리즘은 그 개념이 단순하지만 알고리즘의 효율성을 높이기 위한 방법으로 다양하게 사용되기 때문에 여러 예시들을 통해 분할 정복에 대해 설명하고자 합니다.</p>
<h3><a class="header" href="#merge-sort-1" id="merge-sort-1">Merge Sort</a></h3>
<p><a href="algorithm/divideandconquer/../sort/mergesort">Merge Sort</a> 참고</p>
<h3><a class="header" href="#히스토그램에서-가장-큰-직사각형" id="히스토그램에서-가장-큰-직사각형">히스토그램에서 가장 큰 직사각형</a></h3>
<p>이 <a href="https://www.acmicpc.net/problem/6549">문제</a>는 주어진 히스토그램에서 얻을 구 있는 가장 큰 직사각형의 넓이를 구하는 문제 입니다. </p>
<p>이 문제를 해결하기 위한 다양한 방법이 있지만, 분할 정복을 사용한 풀이에 대해 설명하려고 합니다. 주어진 히스토그램을 가운데에 위치한 직사각형들 사이를 기준으로 두 개의 부분으로 분할하면 히스토그램의 가장 큰 직사각형은 다음과 같이 세 유형 중 하나에 속하게 됩니다.</p>
<pre><code>1) 분할 선 기준으로 왼쪽 히스토그램의 막대들만 사용하여 만들어진 직사각형
2) 분할 선 기준으로 오른쪽 히스토그램의 막대들을 사용하여 만들어진 직사각형
3) 분할 선을 지나는 직사각형
</code></pre>
<p>1번과 2번의 경우는 재귀함수를 통해 구해 주면 되기 때문에 3번 경우만 고려해 주면 문제를 해결할 수 있게 됩니다. 그리고 이 과정은 그리디 알고리즘을 통해 해결하게 됩니다. 가운데 지점을 기준으로 양 쪽으로 막대를 하나씩 추가하면서 직사각형들을 만들면서 각 직사각형의 크기를 구해주게 되며, 막대를 추가할 때는 왼쪽과 오른쪽의 두 막대 중에서 더 높이가 높은 쪽의 막대를 추가하는 것 만으로도 가장 높이가 높은 직사각형을 구할 수 있게 됩니다.</p>
<p>이 문제의 시간복잡도를 분석하면 각 단계에서 \(O(n)\)의 시간이 걸리게 되고 각 단계 마다 전체 히스토그램의 너비가 절반으로 감소하므로 \(\log n\)의 단계를 거치게 됩니다. 따라서 총 걸리는 시간은 \(O(n \log n)\)이 됩니다.</p>
<h3><a class="header" href="#가장-가까운-두-점-구하기" id="가장-가까운-두-점-구하기">가장 가까운 두 점 구하기</a></h3>
<p>이 <a href="https://www.acmicpc.net/problem/2261">문제</a>는 좌표평면 상에 주어진 $n$개의 점들 사이에서 가장 가까운 두 점 사이의 거리를 구해야 하는 문제 입니다. </p>
<p>일반적으로 이 문제는 모든 점 쌍들 간의 거리를 계산하는 방식으로 \( O(n^2) \)의 시간 복잡도로 문제를 해결할 수 있습니다. 그러나 분할 정복을 이용하면 \(O(n \log n)\)의 시간복잡도로 이 문제를 해결 할 수 있게 됩니다.</p>
<p>이 문제에서 분할 정복을 이용하기 위해서 \(n\)개의 정점들을 \(x\) 좌표를 기준으로 정렬 해 줍니다. 이후 \(x\)좌표를 기준으로 점을 두 개의 그룹으로 분할 한 후, 각각의 그룹에 대해 가장 가까운 두 점 사이의 거리를 구하고 최솟값 \(d\)를 구합니다. 이때 각 그룹에 있는 점 사이의 거리를 고려하지 않았으므로 이를 고려해 주어야 하는데, 두 그룹을 나누는 기준선에서 \(x\)좌표의 차이가 \(d\) 이상인 경우 최소 거리가 될 수 없으므로 제외한다. 그리고 이 점들을 \(y\)좌표를 기준으로 정렬하여, \(y\)좌표의 차이가 \(d\) 이하인 점들 간에 거리를 구해 준다. 이때, 각 점에 대해 \(y\)좌표의 차이가 \(d\) 이하인 점의 개수는 7개를 넘지 않으므로, \(O(n)\)만에 모든 점 쌍 사이의 최소 거리를 구할 수 있게 된다. 이 과정을 반복하여 답을 구할 수 있게 된다. 그리고 이 알고리즘의 시간 복잡도를 계산하면, \(O(n \log n)\)이 됩니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
