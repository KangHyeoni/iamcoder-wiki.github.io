<!DOCTYPE HTML>
<html lang="ko" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>IamCoder Wiki</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="IamCoder Wiki">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">IamCoder Wiki</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/iamcoder-wiki/iamcoder-wiki.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#iamcoder-wiki" id="iamcoder-wiki"> IamCoder Wiki</a></h1>
<p>안녕하세요. 나코더(나는코더다) 위키입니다.</p>
<h1><a class="header" href="#iamcoder" id="iamcoder"> IamCoder</a></h1>
<h1><a class="header" href="#sort" id="sort"> Sort</a></h1>
<h2><a class="header" href="#sort정렬이란" id="sort정렬이란">1. Sort(정렬)이란?</a></h2>
<p>프로그래밍에서 정렬이란 무작위로 있는 여러 자료들의 순서를 규칙성 있게 재배열하는 것을 뜻한다. 오름차순, 또는 내림차순으로 정렬하는 것이 일반적이나, 내가 임의로 정한 규칙에 따라 정렬해야 하는 경우도 있다. 정렬해야 하는 자료들의 개수가 <code>n</code>일 때, 정렬알고리즘은 크게 시간복잡도가 \(O(n^2)\), \(O(n\log n)\)과 그 이외인 것으로 나뉘는데, 초급단계에서는 이 \(O(n^2)\) 방법만 알아도 큰 무리는 없다. 구현이 5에서 6줄 정도로 매우 짧고 개념도 직관적으로 이해가 쉽기 때문이다. 그러나 중급단계 이상에서는 100000개 이상의 자료들을 정렬해야 하는 경우가 생겨 \(O(n^2)\)방법으로는 시간초과가 나게 된다. 따라서 \(O(nlogn)\)정렬을 기용해야 하는데, 구현이 모두 \(20\)줄 이상으로 생각보다 쉽지만은 않다. 그러나 우리에게는 하나의 무기가 있는데, 그게 뭔지는 차차 알아가 보도록 하자. 이제부터 설명을 시작할 건데, 이하의 예시코드는 다음의 함수 <code>sortarr()</code> 안에 들어갈 코드로 하자. <code>n</code>개의 <code>int</code>형 자료를 오름차순으로 정렬하여 순서대로 출력하는 프로그램을 다음과 같이 구현하자.</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
int arr[100010], n;
int main()  
{
    scanf(&quot;%d&quot;, &amp;n);
    for(int i=1; i&lt;=n; i++)
        scanf(&quot;%d&quot;, &amp;arr[i]);
    sortarr();  //여기
    for(int i=1; i&lt;=n; i++)
        printf(&quot;%d &quot;, arr[i]);
}
</code></pre>
<h2><a class="header" href="#-on2--sort" id="-on2--sort">2. \( O(n^2) \) Sort</a></h2>
<h3><a class="header" href="#종류" id="종류">2.1. 종류</a></h3>
<ul>
<li><a href="algorithm/sort/./bubblesort.html">Bubble Sort</a></li>
<li><a href="algorithm/sort/./selectionsort.html">Selection Sort</a></li>
<li><a href="algorithm/sort/./insertionsort">Insertion Sort</a></li>
</ul>
<h3><a class="header" href="#여담" id="여담">2.2. 여담</a></h3>
<p>이로써 기본적인 정렬 알고리즘들을 살펴보았는데, 이 알고리즘들은 정렬할 때 쓰일 뿐만 아니라 문제에도 활용이 되는 기본 중의 기본으로 꼭 익혀둬야 한다. 앞으로의 \(O(n\log n)\) 알고리즘들은 더욱 심화된 자료구조와 기법을 사용하므로 모르는 자료구조가 있으면 같은 책의 앞 또는 뒤에 설명이 있으므로 참고하면 되고, 인터넷에서도 설명이 친절하게 되어 있으니 참고하길 바란다.</p>
<h2><a class="header" href="#onlog-n-sort" id="onlog-n-sort">3. \(O(n\log n)\) Sort</a></h2>
<h3><a class="header" href="#종류-1" id="종류-1">3.1. 종류</a></h3>
<ul>
<li><a href="algorithm/sort/./mergesort">Merge Sort</a></li>
<li><a href="algorithm/sort/./heapsort">Heap Sort</a></li>
<li><a href="algorithm/sort/./quicksort">Quick Sort</a></li>
</ul>
<h2><a class="header" href="#기타-정렬" id="기타-정렬">4. 기타 정렬</a></h2>
<h3><a class="header" href="#종류-2" id="종류-2">4.1. 종류</a></h3>
<ul>
<li><a href="algorithm/sort/./countingsort">Counting Sort</a></li>
<li><a href="algorithm/sort/./radixsort">Radix Sort</a></li>
<li><a href="algorithm/sort/./introsort">Intro Sort</a></li>
</ul>
<h2><a class="header" href="#여담-1" id="여담-1">5. 여담</a></h2>
<h1><a class="header" href="#bubble-sort" id="bubble-sort"> Bubble Sort</a></h1>
<h2><a class="header" href="#소개" id="소개">1. 소개</a></h2>
<p>\(O(n^2)\)정렬 중에서 구현이 제일 쉽고 유명한 방법이다. 인접한 두개의 항의 대소를 비교하여 작은 것을 앞으로 보내는 방법이다. 이 방법의 정당성은 이해하기 쉽다. <code>(1, 2), (2, 3), … ,(n-1, n)</code> 번을 순차적으로 비교했을 때, 다른 것은 모르지만 <code>n</code>번째 원소의 값이 최대라는 것은 확신할 수 있다. 이를 <code>n</code>번 반복하여 뒤에서부터 올바르게 숫자를 채워나간다면 정렬이 완료될 것이다. 이를 <code>for</code>문 두개를 이용하여 구현할 수 있고, 총 연산이 \(n*(n-1)/2\)번 실행되므로 시간복잡도는 \(O(n^2)\)이다.</p>
<h2><a class="header" href="#코드" id="코드">2. 코드</a></h2>
<pre><code class="language-c++">void sortarr()
{
    for(int i=1; i&lt;n; i++)
        for(int j=1; j&lt;=n-i; j++)
            if(arr[j]&gt;arr[j+1])
                swap(arr[j], arr[j+1]);
}
</code></pre>
<h3><a class="header" href="#" id="">2.1. </a></h3>
<h1><a class="header" href="#selection-sort" id="selection-sort"> Selection Sort</a></h1>
<h2><a class="header" href="#소개-1" id="소개-1">1. 소개</a></h2>
<p>오히려 삽입정렬보다 개념을 이해하기는 더 쉬울지도 모르겠다. 1번 원소부터 <code>n</code>개의 원소를 다 둘러보면서 최솟값을 찾은 뒤, 그 값을 원래 1번원소와 바꾸고, 2번 원소부터 <code>n</code>번원소까지 이를 반복하는 것이다. 긴말없이 코드로 보여주도록 하겠다.</p>
<h2><a class="header" href="#코드-1" id="코드-1">2. 코드</a></h2>
<pre><code class="language-c++">void sortarr()
{
    int minnum;
    for(int i=1; i&lt;n; i++){
        minnum=i;
        for(int j=i+1; j&lt;=n; j++)
            if(arr[j]&lt;arr[minnum])
                minnum=j;
        swap(arr[i], arr[minnum]);
    }
}
</code></pre>
<h1><a class="header" href="#insertion-sort" id="insertion-sort"> Insertion Sort</a></h1>
<h2><a class="header" href="#소개-2" id="소개-2">1. 소개</a></h2>
<p>\(O(n^2)\)중에서는 개념적으로는 선택정렬까지는 아니지만 버블정렬보다는 쉽지만, 사실 잘 쓰지 않는 정렬 기법이다. \(1\)번부터 \(n\)번의 단계가 있는데, <code>i</code>번째 단계에서는 1번부터 <code>i-1</code>번째원소까지 모두 정렬되어 있는 상황에서 1번부터 <code>i</code>번까지 정렬한다. \(1\)번부터 <code>i-1</code>번까지 정렬되어 있으니, 그냥 뒤에서부터 훑어보면서 이 숫자가 들어갈 곳을 찾으면 된다.</p>
<h2><a class="header" href="#코드-2" id="코드-2">2. 코드</a></h2>
<pre><code class="language-c++">void sortarr()
{
    for(int i=1; i&lt;=n; i++){
        int key=arr[i];
        for(int j=i-1; j&gt;=1; j--){
            if(key&gt;arr[j]){
                arr[j+1]=key;
                break;
            }
            swap(arr[j], arr[j+1]);
        }
    }
}
</code></pre>
<h1><a class="header" href="#merge-sort" id="merge-sort"> Merge Sort</a></h1>
<h2><a class="header" href="#소개-3" id="소개-3">1. 소개</a></h2>
<p>병합정렬은 분할정복, 혹은 <a href="algorithm/sort/../divideandconquer/divideandconquer.html">Divide &amp; Conquer</a>를 사용한 알고리즘으로, 폰 노이만이 개발했다고 한다. 병합정렬의 아이디어는 어떤 배열을 두 조각으로 자르는 거에서 시작한다. 만약 두 조각으로 자른 것들이 이미 정렬되어 있다고 하면, 두 조각을 합쳐서 원래 배열을 정렬시키는 데에는 \(O(n)\)의 시간복잡도밖에 걸리지 않는다. 어떻게 하느냐면, “3, 6, 8, 9”와 “1, 4, 7, 10”을 합칠 때(병합할 때) 두 배열에 대한 피벗을 각각 잡아 피벗들끼리 비교하여 더 작은 것부터 원래 배열에 담는 것이다. 즉 이 경우 3과 1, 3과 4, 6과 4, 6과 7, 8과 7, 8과 10, 9와 10을 순서대로 비교하여 새 배열에는 “1, 3, 4, 6, 7, 8, 9, 10”이 들어가게 된다. 그렇다면, 이를 재귀적으로 계속 절반씩 나눠가면서 각 배열의 절반씩을 정렬하면 될 것이다. 그런데, <code>n</code>을 계속 절반으로 쪼개나가는 것이니 재귀탐색은 깊어봤자 \(\log n\)번씩 밖에 실행되지 않을 것이다! 따라서 전체 알고리즘은 \(O(n\log n)\)안에 실행될 것이다. <code>main</code>함수의 <code>arrsort()</code>를 <code>mergesort(1, n)</code>으로 바꾸고 구현한 병합정렬의 코드이다.</p>
<h2><a class="header" href="#코드-3" id="코드-3">2. 코드</a></h2>
<pre><code class="language-c++">void mergesort(int st, int fin)
{
    if(st&gt;=fin)return;
    int mid=(st+fin)/2;
    mergesort(st, mid);
    mergesort(mid+1, fin);
    int pv1=st, pv2=mid+1, merged[100010], re=st;
    while(pv1&lt;=mid||pv2&lt;=fin){
        if(pv1&gt;mid)merged[re++]=arr[pv2++];
        else if(pv2&gt;fin)merged[re++]=arr[pv1++];
        else merged[re++]=arr[pv1]&lt;=arr[pv2]?arr[pv1++]:arr[pv2++];
    }
    for(int i=st; i&lt;=fin; i++){
        arr[i]=merged[i];
    }
}
</code></pre>
<h1><a class="header" href="#heap-sort" id="heap-sort"> Heap Sort</a></h1>
<h2><a class="header" href="#소개-4" id="소개-4">1. 소개</a></h2>
<p>우선 힙이라는 자료구조를 안다는 가정하에 설명을 시작하도록 하겠다. 우리는 최소 힙을 이용해 선택정렬의 방법을 최적화할 것이다. 선택정렬에서 어떤 구간의 최솟값을 찾는데 그것을 찾기 위해 <code>n</code>개의 칸을 탐색하던지, 힙을 이용하는지의 차이이다. 힙에서는 원소를 추가하는데 \(\log n\), 삭제하는데 \(\log n\)의 시간복잡도가 필요한 반면, 힙의 최소 혹은 최댓값은 상수시간 안에 구해낼 수 있어 이를 이용해 구현한 힙정렬은 \(O(n\log n)\)의 시간복잡도를 가진다. <code>main</code>함수의 <code>sortarr()</code>을 <code>heapsort()</code>로 바꾼 뒤 작성한 코드이다.</p>
<h2><a class="header" href="#코드-4" id="코드-4">2. 코드</a></h2>
<h3><a class="header" href="#heap-sort-without-priority_queue" id="heap-sort-without-priority_queue">2.1. Heap Sort without priority_queue</a></h3>
<pre><code class="language-c++">void in_heap(int num)
{
    heap[++siz]=num;
    int temp=siz;
    while(temp&gt;1){
        if(heap[temp/2]&gt;heap[temp])swap(heap[temp/2], heap[temp]);
        else break;
        temp/=2;
    }
}
void poptop_heap()
{
    swap(heap[1], heap[siz]);
    heap[siz]=987654321;
    siz--;
    int temp=1;
    while(temp&lt;=siz/2){
        if(heap[temp]&lt;=heap[temp*2]&amp;&amp;heap[temp]&lt;=heap[temp*2+1])break;
        if(heap[temp*2]&lt;=heap[temp*2+1]){
            swap(heap[temp], heap[temp*2]);
            temp*=2;
        }
        else{
            swap(heap[temp], heap[temp*2+1]);
            temp*=2;
            temp++;
        }
    }
}
void heapsort()
{
    for(int i=1; i&lt;=n; i++)
        in_heap(arr[i]);
    for(int i=1; i&lt;=n; i++){
        arr[i]=heap[1];
        poptop_heap();
    }
}
</code></pre>
<h3><a class="header" href="#heap-sort-using-priority_queue" id="heap-sort-using-priority_queue">2.2. Heap Sort using priority_queue</a></h3>
<p>힙이란 자료구조는 이미 우선순위 큐의 형태로 구현되어 있으므로 이를 이용하면 코드가 훨씬 간결해진다. 다만 우선순위 큐는 최대 힙으로 원래 수에 -1을 곱해준 값으로 우선순위 큐 안에 넣어주게 되면 최소 힙처럼 사용할 수 있다.</p>
<pre><code class="language-c++">void heapsort()
{
    priority_queue&lt;int&gt; pq;
    for(int i=1; i&lt;=n; i++)
        pq.push(-arr[i]);
    for(int i=1; i&lt;=n; i++){
        arr[i]=-pq.top();
        pq.pop();
    }
}
</code></pre>
<h1><a class="header" href="#quick-sort" id="quick-sort"> Quick Sort</a></h1>
<h2><a class="header" href="#소개-5" id="소개-5">1. 소개</a></h2>
<p>퀵정렬은 다른 알고리즘과는 다르게 시간복잡도가 딱히 정해져 있지 않다. 그 이유는 시간복잡도가 <code>n</code>이 아닌 입력된 배열에 의존하기 때문이다. 퀵정렬은 분할정복을 기본으로 하는데, 어느 하나의 랜덤한 값을 잡아 그보다 작은 값들은 앞으로, 큰 값을 뒤로 몰아놓은 뒤 두 부분을 각각 재귀적으로 정렬해주는 것이다. 시간복잡도는 이때 랜덤하게 잡은 값에 의존하는데, 모든 과정에서 이 랜덤값이 중앙값이면, 시간복잡도는 \(O(nlogn)\)이 되고, 모든 과정에서 랜덤값이 최소이거나 최대이면 시간복잡도가 \(O(n^2)\)이다. 그런데 사실 이럴 일은 매우 드물기 때문에, 안심하고 써도 문제는 없다. <code>main</code>함수의 <code>arrsort()</code>를 <code>quicksort(1, n)</code>으로 바꾸자. 우리는 이 랜덤한 값을 그냥 정렬하는 수들 중 마지막 수로 하자. 실전에서는 이 랜덤한 값을 난수로 처리하거나, 정렬하는 수들중의 중앙값을 이용한다.</p>
<h2><a class="header" href="#코드-5" id="코드-5">2. 코드</a></h2>
<pre><code class="language-c++">void quicksort(int st, int fin)
{
    if(st&gt;=fin)return;
    int temp[100010], fr=st, re=fin-1;
    for(int i=st; i&lt;fin; i++){
        if(arr[i]&lt;=arr[fin])temp[fr++]=arr[i];
        else temp[re--]=arr[i];
    }
    for(int i=st; i&lt;fin; i++)
        arr[i]=temp[i];
    swap(arr[fr], arr[fin]);
    quicksort(st, re);
    quicksort(fr, fin);
}
</code></pre>
<h1><a class="header" href="#counting-sort" id="counting-sort"> Counting Sort</a></h1>
<h2><a class="header" href="#소개-6" id="소개-6">1. 소개</a></h2>
<p>정렬하는 수들의 크기가 그리 크지 않고, 모두 0이상일 때 쓰는 정렬인데, 다른 정렬들과 달리 메모리가 굉장히 많이 필요하다. 그러나 수들이 전부 많이 작으면 이보다 빠른 정렬은 없을 것이다. 시간복잡도가 무려 \(O(n+max(arr[i]))\)로, 배열값만 적당하다면 선형시간 안에 정렬을 할수 있기 때문이다. 정렬의 이름답게 각 원소의 개수를 배열에 저장해 둔 뒤 그 자료를 이용해 정렬을 하는 것이다. 다만 최댓값이 9백만 정도가 넘어가면 일반적인 문제에서 메모리 초과가 나게 되는 치명적인 단점이 있다.</p>
<h2><a class="header" href="#코드-6" id="코드-6">2. 코드</a></h2>
<pre><code class="language-c++">void sortarr()
{
    int cnt[100010];
    fill(cnt, cnt+100005, 0);
    for(int i=1; i&lt;=n; i++)cnt[arr[i]]++;
    int num=0, pv=0;
    while(num&lt;n){
        if(!cnt[pv])pv++;
        else{
            arr[++num]=pv;
            cnt[pv]--;
        }
    }
}
</code></pre>
<h1><a class="header" href="#radix-sort" id="radix-sort"> Radix Sort</a></h1>
<h2><a class="header" href="#소개-7" id="소개-7">1. 소개</a></h2>
<p>카운팅 정렬의 약점을 완벽하게 보완해주는 정렬 방법이다. 시간복잡도의 <code>d</code>는 각 원소의 자릿수중 최댓값인데, 각 자리수별로 카운팅 정렬을 실행하여 정렬하여 큰 수에 대해서도 정렬을 시행할 수 있다. 물론 가장 큰 자릿수부터 정렬을 시행해 주어야 할 것이다. 래딕스 정렬은 Big Integer라 불리는 <code>unsigned long long int</code> 범위를 훨씬 벗어나는, \(10^{100}\)과 같은 수들을 정렬할 때 유용하게 쓰일 수 있다. 코드는 카운팅 정렬의 것을 약간만 수정하면 되므로 생략하도록 하겠다.</p>
<h1><a class="header" href="#intro-sort" id="intro-sort"> Intro Sort</a></h1>
<h2><a class="header" href="#소개-8" id="소개-8">1. 소개</a></h2>
<p>퀵정렬과 힙정렬을 합한 정렬이다. 기본적으로 퀵정렬을 하지만, 어느정도 재귀가 깊어지면 힙정렬을 이용해 퀵정렬에서 나올 수 있는 최악의 시간복잡도를 피해준다. </p>
<h2><a class="header" href="#stl-sort" id="stl-sort">2. STL sort</a></h2>
<p>하지만 이 인트로 정렬은 구현이 지금까지 나온 모든 정렬보다 쉽다! 왜냐하면, C++에서 이 인트로 정렬을 지원해주기 때문에 딱 한줄이면 정렬이 마무리 된다! 실전에서 가장 유용하게 쓰이는 함수라 봐도 무방하고, 그만큼 빠른 정렬이기에 이 단원을 읽으면서 이거 하나만은 꼭 알고 가자. <code>&lt;algorithm&gt;</code> 헤더파일에 존재하는 <code>sort</code>함수는 <code>sort(시작포인터, 끝포인터, 비교함수의 포인터)</code>의 꼴로 이루어져있는데, 3번째 항을 빈칸으로 남겨둔다면 오름차순 정렬을 시행한다. </p>
<h3><a class="header" href="#비교-함수" id="비교-함수">2.1. 비교 함수</a></h3>
<p><code>sort</code>함수의 가장 큰 장점은 <code>int</code>뿐만 아니라 내가 임의로 만든 구조체라던지 <code>pair</code>등의 대소비교가 가능한 모든 자료구조에 대해서 적용이 가능하다는 것이다! 비교함수의 작성법에 대해 아래 코드를 보면서 설명하도록 하겠다.</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
struct data
{
    int a;
    char c;
}arr[100010];
bool comp(data x, data y)
{
    if(x.a!=y.a)return x.a&lt;y.a;
    return x.c&lt;y.c;
}
int main()
{
    int n;
    scanf(&quot;%d&quot;, &amp;n);
    for(int i=1; i&lt;=n; i++)
        scanf(&quot;%d %c&quot;, &amp;arr[i].a, &amp;arr[i].c);
    sort(arr+1, arr+n+1, comp);
    for(int i=1; i&lt;=n; i++)
        printf(&quot;%d %c\n&quot;, arr[i].a, arr[i].c);
}
</code></pre>
<p>위와 같이 코드를 작성하면, 각 구조체 <code>a</code>값이 작은것, <code>c</code>값이 작은 것의 우선순위로 구조체들이 정렬된다. 즉, <code>sort</code>함수에 내장된 코드들이 <code>comp</code> 함수를 호출할때 <code>x</code>가 앞의 원소, <code>y</code>가 뒤의 원소일때 <code>comp(x, y)</code>가 리턴하는 값이 <code>true</code> 이면 바꾸지 않고 <code>false</code>일때 두 자리가 바뀌게 된다. 다른건 몰라도 이 <code>sort</code>함수의 사용법만큼은 꼭 익혀두기 바란다.</p>
<h1><a class="header" href="#divide--conquer" id="divide--conquer"> Divide &amp; Conquer</a></h1>
<h2><a class="header" href="#소개-9" id="소개-9">1. 소개</a></h2>
<p>Divide &amp; Conquer(D&amp;C) 혹은 분할 정복이라 불리는 문제 해결 기법은 최적해를 구할 때 유용하게 사용될 수 있는 기법 중 하나로, 주어진 문제를 두개 이상의 부분 문제들로 분할하고 각각을 해결한 후 이를 다시 합쳐 주어진 문제를 해결하는 방식입니다. 다시 말해, 문제를 여러개의 해결 가능한 부분 문제들로 나누고 각각을 해결한 후 이 결과를 적절히 융합하여 원래 문제의 답을 구하는 방식을 반복하여 문제를 해결하는 방법입니다. 이 방식을 사용하는 이유는 각각을 부분 문제로 분할하고 이를 각각 해결하는 방식이 다른 방식들에 비해 효율적으로 작동하는 경우가 많기 때문입니다. </p>
<h2><a class="header" href="#방법" id="방법">2. 방법</a></h2>
<p>일반적으로 분할 정복 알고리즘의 과정을 정리하자면 다음과 같습니다.</p>
<ol>
<li>문제가 분할이 가능하다면 2개 이상의 부분 문제들로 분할 (Divide)</li>
<li>나뉜 문제가 추가적으로 분할이 가능할 경우 다시 분할, 그렇지 않을 경우 문제를 해결 (Conquer)</li>
<li>아래 단계에서 Conquer 과정을 통해 답을 구한 부분 문제들을 다시 합하여 원래 문제의 답을 구함</li>
</ol>
<h2><a class="header" href="#예시" id="예시">3. 예시</a></h2>
<p>분할 정복 알고리즘은 그 개념이 단순하지만 알고리즘의 효율성을 높이기 위한 방법으로 다양하게 사용되기 때문에 여러 예시들을 통해 분할 정복에 대해 설명하고자 합니다.</p>
<h3><a class="header" href="#a-hrefalgorithmdivideandconquersortmergesortmerge-sorta" id="a-hrefalgorithmdivideandconquersortmergesortmerge-sorta">3.1. <a href="algorithm/divideandconquer/../sort/mergesort">Merge Sort</a></a></h3>
<h3><a class="header" href="#히스토그램에서-가장-큰-직사각형" id="히스토그램에서-가장-큰-직사각형">3.2. 히스토그램에서 가장 큰 직사각형</a></h3>
<p>이 <a href="https://www.acmicpc.net/problem/6549">문제</a>는 주어진 히스토그램에서 얻을 구 있는 가장 큰 직사각형의 넓이를 구하는 문제 입니다. </p>
<p>이 문제를 해결하기 위한 다양한 방법이 있지만, 분할 정복을 사용한 풀이에 대해 설명하려고 합니다. 주어진 히스토그램을 가운데에 위치한 직사각형들 사이를 기준으로 두 개의 부분으로 분할하면 히스토그램의 가장 큰 직사각형은 다음과 같이 세 유형 중 하나에 속하게 됩니다.</p>
<pre><code>1) 분할 선 기준으로 왼쪽 히스토그램의 막대들만 사용하여 만들어진 직사각형
2) 분할 선 기준으로 오른쪽 히스토그램의 막대들을 사용하여 만들어진 직사각형
3) 분할 선을 지나는 직사각형
</code></pre>
<p>1번과 2번의 경우는 재귀함수를 통해 구해 주면 되기 때문에 3번 경우만 고려해 주면 문제를 해결할 수 있게 됩니다. 그리고 이 과정은 그리디 알고리즘을 통해 해결하게 됩니다. 가운데 지점을 기준으로 양 쪽으로 막대를 하나씩 추가하면서 직사각형들을 만들면서 각 직사각형의 크기를 구해주게 되며, 막대를 추가할 때는 왼쪽과 오른쪽의 두 막대 중에서 더 높이가 높은 쪽의 막대를 추가하는 것 만으로도 가장 높이가 높은 직사각형을 구할 수 있게 됩니다.</p>
<p>이 문제의 시간복잡도를 분석하면 각 단계에서 \(O(n)\)의 시간이 걸리게 되고 각 단계 마다 전체 히스토그램의 너비가 절반으로 감소하므로 \(\log n\)의 단계를 거치게 됩니다. 따라서 총 걸리는 시간은 \(O(n \log n)\)이 됩니다.</p>
<h3><a class="header" href="#가장-가까운-두-점-구하기" id="가장-가까운-두-점-구하기">3.3. 가장 가까운 두 점 구하기</a></h3>
<p>이 <a href="https://www.acmicpc.net/problem/2261">문제</a>는 좌표평면 상에 주어진 $n$개의 점들 사이에서 가장 가까운 두 점 사이의 거리를 구해야 하는 문제 입니다. </p>
<p>일반적으로 이 문제는 모든 점 쌍들 간의 거리를 계산하는 방식으로 \( O(n^2) \)의 시간 복잡도로 문제를 해결할 수 있습니다. 그러나 분할 정복을 이용하면 \(O(n \log n)\)의 시간복잡도로 이 문제를 해결 할 수 있게 됩니다.</p>
<p>이 문제에서 분할 정복을 이용하기 위해서 <code>n</code>개의 정점들을 <code>x</code> 좌표를 기준으로 정렬 해 줍니다. 이후 <code>x</code>좌표를 기준으로 점을 두 개의 그룹으로 분할 한 후, 각각의 그룹에 대해 가장 가까운 두 점 사이의 거리를 구하고 최솟값 <code>d</code>를 구합니다. 이때 각 그룹에 있는 점 사이의 거리를 고려하지 않았으므로 이를 고려해 주어야 하는데, 두 그룹을 나누는 기준선에서 \(x\)좌표의 차이가 \(d\) 이상인 경우 최소 거리가 될 수 없으므로 제외한다. 그리고 이 점들을 \(y\)좌표를 기준으로 정렬하여, \(y\)좌표의 차이가 \(d\) 이하인 점들 간에 거리를 구해 준다. 이때, 각 점에 대해 \(y\)좌표의 차이가 \(d\) 이하인 점의 개수는 7개를 넘지 않으므로, \(O(n)\)만에 모든 점 쌍 사이의 최소 거리를 구할 수 있게 된다. 이 과정을 반복하여 답을 구할 수 있게 된다. 그리고 이 알고리즘의 시간 복잡도를 계산하면, \(O(n \log n)\)이 됩니다.</p>
<h1><a class="header" href="#lcs" id="lcs"> LCS</a></h1>
<h2><a class="header" href="#소개-10" id="소개-10">1. 소개</a></h2>
<p>최장 공통 부분 수열은 주어진 여러 개의 수열 모두의 부분 수열이 되는 수열들 중에 가장 긴 것입니다. 부분 수열은 그 수열의 일부 항을 원래 순서대로 나열해 얻을 수 있는 수열입니다. 이때 꼭 연속하지 않아도 되며, 연속한 경우는 최장 공통 문자열이라고 부릅니다.</p>
<p>사실 최장 공통 부분 수열은 문자를 다룰 수도 있습니다. '공통 부분 수열'과 '공통 문자열'의 차이는 연속해야 하는지의 여부입니다. 따라서 '공통 부분 수열'이 꼭 숫자로만 이루어지지 않을 수도 있습니다. <em>1243</em> 은 <em>ABDC</em>일 수도 있고, _@^$&amp;_일 수도 있음을 유의하시기 바랍니다.</p>
<p>아래와 같이 짧은 LCS는 매우 간단하므로 눈으로도 쉽게 답을 찾을 수 있습니다.</p>
<img src="algorithm/dp/./LCS1.JPG" width = 500 >
<p><em>123762</em>와 <em>123587</em>의 LCS를 찾아봅시다.</p>
<p>두 수열 모두 부분 수열로 <em>137</em>, <em>17</em>, <em>237</em> 등을 가지고 있습니다. 이때 LCS는 <em>1237</em>이 되고, 그 길이는 4입니다.</p>
<h2><a class="header" href="#dp-table" id="dp-table">2. DP Table</a></h2>
<p>LCS를 찾기 위한 일반적인 방법은 DP(동적계획법) Table을 만드는 것입니다. </p>
<img src="algorithm/dp/./LCS2.jpg" width = 500 > 
<p>주어진 수열이 <em>123762</em>와 <em>123587</em>라고 합시다. 이 표의 가로축과 세로축은 각각의 수열을 의미합니다. 이 표에서 <code>i</code>번째 행,<code>j</code>번째 열의 수를 <code>ARR[i][j]</code>라 할 때 <code>ARR[i][j]</code>는 <code>A</code>를 <code>i</code>번째 수, <code>B</code>를 <code>j</code>번째 수 까지 고려했을 때 최장 수열의 길이입니다. 첫 번째 열과 첫 번째 행은 아직 아무 수도 고려하지 못한 상태이기 떄문에, 최장 수열의 길이는 0입니다.
0이 아닌 <code>i</code>, <code>j</code>에 대해 <code>ARR[i][j]</code>를 다음과 같이 정의할 수 있습니다.</p>
<pre><code class="language-c++">if(A[i]==B[j]){
  // A[i]와 B[j]가 같은 경우
  ARR[i][j] = max(max(ARR[i-1][j], ARR[i][j-1]), ARR[i-1][j-1]+1);
}else{
  // A[i]와 B[j]가 다른 경우
  ARR[i][j] = max(ARR[i-1][j], ARR[i][j-1]);
}
</code></pre>
<p>만약 <code>A[i]</code>와 <code>B[j]</code>가 다르다면, 아무것도 추가할 수 없으므로 <code>A[i]</code>를 확인하기 전 단계인 <code>ARR[i-1][j]</code>와 <code>B[j]</code>를 확인하기 전 단계인 <code>ARR[i][j-1]</code> 중 더 큰 값을 저장하는 것입니다.
<code>A[i]</code>와 <code>B[j]</code>가 같다면 위의 두 선택지에 더해 세 번째 선택지가 존재합니다. 두 수가 같으므로 LCS의 마지막 자리에 추가할 수 있고, 이는 두 수를 모두 고려하기 전까지의 LCS에 1을 더한 <code>ARR[i-1][j-1] + 1</code>입니다.
이 과정을 모두 마치고 나면 LCS의 길이는 표의 가장 마지막 위치 <code>ARR[6][6]</code>에 저장되어 있습니다. (<code>A</code>와 <code>B</code>가 모두 6자리이기 때문입니다.) 즉, <code>A</code>와 <code>B</code>의 모든 수를 다 고려했을 때의 LCS를 의미합니다.
만약 LCS의 길이 뿐만이 아닌 LCS 자체를 구하고 싶다면, 위 표에서 빨간색으로 채워진 칸들을 역으로 추적하면 됩니다. 
위 표에서 예시를 들어 보도록 하겟습니다. 선택되었기에 빨간색이 칠해진 칸들을 보면 모두 공통점이 있습니다. 같은 숫자를 가진 칸들 중 가장 왼쪽 위의 칸이라는 것입니다. 이것은 전 칸에서 넘어올 때 길이가 1 늘었다는 뜻이고, 그 칸이 LCS에 포함된다는 뜻입니다. 따라서 LCS를 구하려면, 끝에서 시작해 왼쪽이나 위에 같은 수가 있으면 그곳으로 가고, 왼쪽 칸과 윗칸이 모두 자신보다 작다면 자신을 LCS에 추가한 후 왼쪽 위에 있는 칸으로 가면 됩니다.</p>
<h2><a class="header" href="#code" id="code">3. Code</a></h2>
<p>지금까지 설명한 내용이 그대로 담겨 있는 문제가 있습니다. 따라서 구현 코드와 문제 설명을 같이 하겠습니다.<a href="https://www.acmicpc.net/problem/9252">이 문제</a>는 두 문자열을 입력받은 후, LCS의 길이와 LCS를 출력하는 문제입니다.</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
char A[1010], B[1010], LCS[1010];
int DP[1010][1010], LEN;
int main() {
    scanf(&quot;%s&quot;, A + 1);
    scanf(&quot;%s&quot;, B + 1);
    
    // strlen()의 이용을 위해
    // A[0]과 B[0]에 임의의 문자를 입력
    A[0] = B[0] = '.';
    
    // lenA와 lenB는 각각 A와 B의 길이
    int lenA = strlen(A) - 1, lenB = strlen(B) - 1;
    
    for(int i = 1; i &lt;= lenA; i++) {
        for(int j = 1; j &lt;= lenB; j++) {
            if(A[i] == B[j])
                // A[i]와 B[j]가 같아서
                // LCS를 늘릴 수 있는 경우
                DP[i][j] = max(DP[i - 1][j - 1] + 1, max(DP[i - 1][j], DP[i][j - 1]));
            else
                // 다른 경우
                DP[i][j] = max(DP[i - 1][j], DP[i][j - 1]);
        }
    }
    
    LEN = DP[lenA][lenB];
    
    //LCS의 길이 출력
    printf(&quot;%d\n&quot;, LEN);
    
    int a = lenA, b = lenB;
    
    while(LEN &gt; 0) {
        if(DP[a][b] == DP[a - 1][b]) {
            // DP[a][b]가 색칠되지 않은 경우
            a--;
        }
        else if(DP[a][b] == DP[a][b - 1]) {
            // DP[a][b]가 색칠되지 않은 경우
            b--;
        }
        else {
            // DP[a][b]가 색칠되었고 LCS에 해당하는 경우
            
            // A[a]와 B[b]중 어떤 것을 써도 상관없다.
            LCS[LEN - 1] = A[a];
            a--;
            b--;
            LEN--;
        }
    }
    
    //LCS 출력
    printf(&quot;%s\n&quot;, LCS);
}
</code></pre>
<h1><a class="header" href="#bitmask" id="bitmask"> Bitmask</a></h1>
<h2><a class="header" href="#소개-11" id="소개-11">1. 소개</a></h2>
<p>그럼 이제 본격적으로 비트마스킹이 뭔지 설명할 차례입니다. 비트마스킹에는 <a href="datastructure/intermediate/bitmask/../bitoperator/bitoperator.html">비트 연산자</a>가 모든 연산을 차지합니다. 먼저 비트마스크(Bitmask)의 정의부터 살펴봅시다. 비트마스크란, 비트를 변경하여 정보를 저장하는 정수를 뜻합니다. 비트마스킹 기법은 이 비트마스크를 사용하여 메모리 및 연산속도를 대폭 줄일 수 있습니다.</p>
<h2><a class="header" href="#장점" id="장점">2. 장점</a></h2>
<p>비트마스크는 다음과 같은 주요 장점이 있습니다.</p>
<ul>
<li>
<p><strong>메모리 사용량의 큰 단축</strong></p>
<p>비트마스크는 하나의 bool연산자를 하나의 비트로 대체할 수 있습니다. 실제 하나의 int형 정수는 32비트이므로, bool 연산자 32개(\(2 \times 32 = 64\)(byte))를 int형 정수 1개(4(byte))로 줄일 수 있습니다. 그렇게 함으로써, 긴 bool 배열을 짧은 정수배열로 바꾸어 메모리를 16배 가량 줄일 수 있게 해줍니다.</p>
</li>
<li>
<p><strong>실행시간의 단축</strong></p>
<p>실제로 연산 <code>4 * 2</code>와 <code>4 &lt;&lt; 1</code>은 차이가 눈에 띄게 있지 않습니다. 그러나 이 연산이 몇천번정도 반복된다면 이야기가 달라집니다. 일반적인 사칙연산은 비트연산을 여러번 진행한 다음 그 결과값을 반환하지만 비트연산은 딱 한번의 연산만 필요하기 때문에 실행시간을 많게는 반 가량 단축시킬 수 있습니다.</p>
</li>
<li>
<p><strong>코드 길이의 단축</strong></p>
<p>비트마스크를 쓸 경우 복잡한 코드가 한주로 짧게 줄어들 수 있습니다. 비트마스킹만 잘 안다면, 코드의 가독성이 향상될 것입니다.</p>
</li>
</ul>
<h2><a class="header" href="#코드-7" id="코드-7">3. 코드</a></h2>
<p>비트마스킹으로 배열에 있는 많은 기능들을 구현해 봅시다. 대부분의 구현들이 간단한 비트연산 한번으로 가능합니다. 다음 코드를 봅시다.</p>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt; 

int Bitmask;

int main(){
    Bitmask = 10; //이진수로 1010
    int n, tmp = Bitmask;
    scanf(&quot;%d&quot;, &amp;n);
    if(Bitmask &amp; (1 &lt;&lt; n)) printf(&quot;arr[%d] is true.\n&quot;, n); //원소의 존재 확인, 저기서 1과 같냐는 조건을 추가한다면 제대로 동작하지 않습니다.
    
    scanf(&quot;%d&quot;, &amp;n);
    Bitmask |= (1 &lt;&lt; n); //원소 추가
    printf(&quot;%dth(st, nd, rd) element added.\n&quot;, n);
  
    scanf(&quot;%d&quot;, &amp;n);
    Bitmask &amp;= ~(1 &lt;&lt; n); //원소 삭제, 만약 원소가 없으면 그대로
    printf(&quot;%dth(st, nd, rd) element deleted.(if in array)&quot;, n);
    
    scanf(&quot;%d&quot;, &amp;n);
    Bitmask ^= (1 &lt;&lt; n); //원소 토글, if문이 필요 없습니다.
    printf(&quot;%dth(st, nd, rd) element toggled.&quot;, n);

    int Union = (Bitmask | tmp); //합집합, for문 불필요
    
    int Intersection = (Bitmask &amp; tmp); //교집합
    
    int Relative_Component = (Bitmask &amp; ~tmp); //차집합
    
    int Symmetric_Difference = (Bitmask ^ tmp) //대칭차집합
    
    int Complement_Set = ~Bitmask //여집합

    int Min_element = (Bitmask &amp; -Bitmask); //최소원소

    Bitmask &amp;= (Bitmask - 1); //최소원소 지우기

    for(int Sub = Bitmask, i = 1; Sub; Sub = ((Sub - 1) &amp; Bitmask), i++){
        printf(&quot;Subset %d: %d&quot;, i, Sub); //모든 부분집합 순회
    }

    //비트마스킹을 사용할 때는 모든 비트 연산의 주변에 괄호를 치는 것을 추천합니다. 잘못하면 연산자 우선순위 때문에 어이없는 오류가 날 수도 있기 떄문입니다.

}
</code></pre>
<h2><a class="header" href="#코드-설명" id="코드-설명">4. 코드 설명</a></h2>
<p>차근차근 짚어나가 보죠.</p>
<h3><a class="header" href="#원소-확인" id="원소-확인">4.1. 원소 확인</a></h3>
<p>원소 확인은 쉬프트 연산을 통해 1비트의 자리를 설정하고, AND연산을 하여 0인지 0이 아닌 다른 값인지 확인해 줍니다. 이떄, AND연산의 결과가 꼭 1은 아닙니다. 왜냐하면 AND연산은 참 거짓이 아닌 계산의 결과값, 즉 그 자리에 비트가 있다면 2의 거듭제곱을 반환하기 떄문입니다. 시간복잡도는 \(O(1)\)입니다.</p>
<h3><a class="header" href="#원소-추가" id="원소-추가">4.2. 원소 추가</a></h3>
<p>OR연산을 통해 원소를 추가해 줍니다. 설령 이미 원소가 있더라도, 원소는 다르게 바뀌지 않습니다. 있으면 항상 1이기 때문에 1이 1로 바뀌는 것일 뿐입니다. 즉, 변화가 없습니다. 시간복잡도는 \(O(1)\)입니다.</p>
<h3><a class="header" href="#원소-삭제" id="원소-삭제">4.3. 원소 삭제</a></h3>
<p>AND연산을 통해 원소를 삭제해 줍니다. 삭제할 위치의 비트만 1인 상태에서 NOT연산을 취해 준다면 비트가 반전되어 그 비트만 삭제됩니다. 설령 원소가 이미 없더라도 괜찮습니다. 마찬가지로 0이 그대로 0으로 갱신되는 것 뿐입니다. 시간복잡도는 \(O(1)\)입니다.</p>
<h3><a class="header" href="#원소-반전토글" id="원소-반전토글">4.4. 원소 반전(토글)</a></h3>
<p>XOR연산으로 원소를 토글해줍니다. 원소가 1이면 0으로, 0이면 1으로 바꿔준다는 것을 쉽게 알 수 있습니다. 여기서 눈여겨봐야 할 점은, 조건문이 전혀 필요없다는 것입니다. 비트연산 하나로 간단하게 끝낼 수 있다는 점, 이게 바로 비트마스킹의 장점입니다. 시간복잡도는 \(O(1)\)입니다.</p>
<h3><a class="header" href="#합집합" id="합집합">4.5. 합집합</a></h3>
<p>두 집합 사이 OR연산으로 원소가 둘 중 한곳이라도 있다면 전부 있음으로 표시하여 합집합을 계산합니다. </p>
<h3><a class="header" href="#교집합" id="교집합">4.6. 교집합</a></h3>
<p>두 집합 사이 AND연산으로 원소가 두 곳 모두 있다면 있음으로 표시하여 교집합을 계산합니다. </p>
<h3><a class="header" href="#차집합" id="차집합">4.7. 차집합</a></h3>
<p>한 집합을 비트반전(NOT) 반전한 다음 AND 연산으로 원소가 반전한 집합과 반전하지 않은 집합 둘 다 있다면 전부 있음으로 표시하여 차집합을 계산합니다. </p>
<h3><a class="header" href="#대칭차집합" id="대칭차집합">4.8. 대칭차집합</a></h3>
<p>두 집합 사이 XOR연산으로 원소의 유무가 다르다면 전부 있음으로 표시하여 대칭차집합을 계산합니다. </p>
<h3><a class="header" href="#여집합" id="여집합">4.9. 여집합</a></h3>
<p>NOT연산으로 원소를 반전하여 여집합을 계산합니다.</p>
<h3><a class="header" href="#최소-원소-찾기" id="최소-원소-찾기">4.10. 최소 원소 찾기</a></h3>
<p>최소원소 찾기는 비트마스킹의 장점을 다시 한번 보여주는 좋은 예입니다. 위 식은 보수를 이용한 것으로, 보수가 <code>-N-1</code>으로 표현가능함을 이용하여 가장 작은 원소를 손쉽게 계산할 수 있습니다.</p>
<p>또한, 1을 빼면 최소원소 직전의 0들은 모두 1로 반전되고 최소비트 하나만 0으로 반전되기 떄문에 최소비트를 빠르게 뺄 수 있습니다. 최소 원소를 구하고 반전시키는 것보다 훨씬 빠릅니다. </p>
<h3><a class="header" href="#시간복잡도" id="시간복잡도">4.11. 시간복잡도</a></h3>
<p>여기까지 모든 연산의 시간복잡도는 모두 \(O(1)\)입니다.</p>
<h3><a class="header" href="#부분집합-순회" id="부분집합-순회">4.12. 부분집합 순회</a></h3>
<p>마지막으로 부분집합 순회입니다. 저 순회는 다른거에 비해 굉장히 강력합니다. 매우 간단하게 모든 부분집합을 탐색하는 코드를 만들 수 있기 떄문이죠. 먼저 1을 뺀다면 최하위 비트와 그 밑의 0들은 전부 반전됩니다. 그 후 원래 집합과의 교집합을 구한다면, 그 원집합에 속하지 않는 원소들은 모두 꺼지게 됩니다. 그리하여 모든 부분집합을 탐색해나갈 수 있습니다.</p>
<p>시간복잡도는 \(O(2^{N})\)입니다.</p>
<h2><a class="header" href="#예제" id="예제">5. 예제</a></h2>
<p>비트마스킹은 주로 동적계획법, 즉 다이나믹 프로그래밍과 같이 자주 쓰입니다. 다음 예제를 봅시다. 이 문제는 백준 OJ의 <a href="https://www.acmicpc.net/problem/2098">외판원 순회</a> 문제입니다.</p>
<blockquote>
<p>외판원 순회 문제는 영어로 Traveling Salesman problem (TSP) 라고 불리는 문제로 computer science 분야에서 가장 중요하게 취급되는 문제 중 하나이다. 여러 가지 변종 문제가 있으나, 여기서는 가장 일반적인 형태의 문제를 살펴보자.</p>
<p>1번부터 N번까지 번호가 매겨져 있는 도시들이 있고, 도시들 사이에는 길이 있다. (길이 없을 수도 있다) 이제 한 외판원이 어느 한 도시에서 출발해 N개의 도시를 모두 거쳐 다시 원래의 도시로 돌아오는 순회 여행 경로를 계획하려고 한다. 단, 한 번 갔던 도시로는 다시 갈 수 없다. (맨 마지막에 여행을 출발했던 도시로 돌아오는 것은 예외) 이런 여행 경로는 여러 가지가 있을 수 있는데, 가장 적은 비용을 들이는 여행 계획을 세우고자 한다.</p>
<p>각 도시간에 이동하는데 드는 비용은 행렬 <code>W[i][j]</code>형태로 주어진다. <code>W[i][j]</code>는 도시 <code>i</code>에서 도시 <code>j</code>로 가기 위한 비용을 나타낸다. 비용은 대칭적이지 않다. 즉, <code>W[i][j]</code> 는 <code>W[j][i]</code>와 다를 수 있다. 모든 도시간의 비용은 양의 정수이다. <code>W[i][i]</code>는 항상 0이다. 경우에 따라서 도시 <code>i</code>에서 도시 <code>j</code>로 갈 수 없는 경우도 있으며 이럴 경우 <code>W[i][j] = 0</code>이라고 하자.</p>
<p>N과 비용 행렬이 주어졌을 때, 가장 적은 비용을 들이는 외판원의 순회 여행 경로를 구하는 프로그램을 작성하시오.</p>
<p><strong>입력</strong></p>
<p>첫째 줄에 도시의 수 <code>N</code>이 주어진다. (\(2 \leq N \leq 16\) 다음 <code>N</code>개의 줄에는 비용 행렬이 주어진다. 각 행렬의 성분은 1,000,000 이하의 양의 정수이며, 갈 수 없는 경우는 0이 주어진다. <code>W[i][j]</code>는 도시 <code>i</code>에서 <code>j</code>로 가기 위한 비용을 나타낸다.</p>
<p>항상 순회할 수 있는 경우만 입력으로 주어진다.</p>
<p><strong>출력</strong></p>
<p>첫째 줄에 외판원의 순회에 필요한 최소 비용을 출력한다.</p>
<p><strong>입출력 예시</strong></p>
<p><em><strong>Input</strong></em></p>
<p><em>4</em></p>
<p><em>0 10 15 20</em></p>
<p><em>5  0  9 10</em></p>
<p><em>6 13  0 12</em></p>
<p><em>8  8  9  0</em></p>
<p><em><strong>Output</strong></em></p>
<p><em>35</em></p>
</blockquote>
<p>이 문제의 풀이 방법은 비트마스크와 다이나믹 프로그래밍입니다. 먼저 시작 도시를 정한 후, 그 도시로 부터 갈 수 있는 방법을 완전탐색 해 나갑니다. 이떄, 그냥 일반적인 완전탐색은 시간이 엄청나게 오래 걸리므로, 다이나믹 프로그래밍을 사용합니다. 점화식은 다음과 같습니다.</p>
<p>\(TSP(curr, visited) = min(TSP(next, visited \cup next) + dist[curr][next]) (0 \leq next \leq N - 1, next \neq curr, next \notin visited)\)</p>
<p>현재 도시의 순회 최솟값을 알기 위해 다음 돌아가는 모든 경로를 탐색한 후 그 값을 DP에 저장하면 문제가 풀릴 수 있습니다. 이떄, 집합 visited를 비트마스킹으로 구현할 수 있습니다.</p>
<p>이 코드는 DP의 원소의 개수가 \(2^{N} \times N\)이고 이를 각 도시마다 한 번씩 N번 탐색하여 총 시간복잡도는 \(O(2^{N} \times N^{2})\)입니다. 만약 다이나믹기법을 쓰지 않았다면 모두 일일이 탐색해야 하므로 시간복잡도는 \(O(N!)\)이 되었을 것입니다. 느리기는 하지만, 확실히 빨라졌습니다. 여기에 비트마스킹으로 연산속도까지 빨라졌으니, 문제에서 주어진 N의 범위쯤은 거뜬합니다.</p>
<h1><a class="header" href="#bit-operator" id="bit-operator"> Bit Operator</a></h1>
<h2><a class="header" href="#소개-12" id="소개-12">1. 소개</a></h2>
<p>비트 연산자란, 각 수의 비트로(즉, 0과 1로) 연산을 진행하는 연산자입니다. 비트 연산자는 다음과 같이 있습니다.</p>
<ul>
<li>비트 AND(&amp;)</li>
<li>비트 OR(|)</li>
<li>비트 XOR(^)</li>
<li>비트 LSHIFT(&lt;&lt;), RSHIFT(&gt;&gt;)</li>
<li>비트 NOT(~)</li>
</ul>
<p>비트 연산자를 사용하면 좋은 점이 무엇일까요? 그 이유는 연산속도가 빨라지기 때문입니다. 비트연산은 일반 사칙연산 연산자와는 달리 연산속도가 빨라 시간단축에 용이할 수 있습니다. 시간단축은 알고리즘 문제를 풀때 매우 중요한 요소라는 것은 독자 여러분들도 잘 알고 있을 것입니다.</p>
<h2><a class="header" href="#bit-and" id="bit-and">2. BIT AND</a></h2>
<p>비트 AND연산자는 같은자리의 Bit를 비교하여 둘다 1이면 그 자리에 1을, 둘 중 하나라도 1이 아니면 0을 계산 결과로 내놓아 하나의 수를 만듭니다. Bit 연산이므로 2진수를 기준으로 연산하며, 일반 사칙연산보다 그 속도가 빠릅니다. 예를 들어 다음 코드를 보면</p>
<pre><code class="language-c++">printf(&quot;%d\n&quot;, 23 &amp; 9); //1
printf(&quot;%d\n&quot;, 22 &amp; 11); //2
printf(&quot;%d\n&quot;, 31 &amp; 31); //31
</code></pre>
<p>같은 연산을 할 수 있습니다.</p>
<p>맨 위의 식을 예로 들어본다면 23은 이진수로 \(10111_{(2)}\)이고 9는 이진수로 \(1001_{(2)}\)이기 때문에 &amp;연산을 취해준다면</p>
<img src="datastructure/intermediate/bitoperator//Users/retr0/Desktop/iamcoder-wiki.github.io/src/datastructure/intermediate/bitmask/bitmask1.png" width = 200 >
<p>와 같이 됩니다.</p>
<p>그렇다면 논리 AND와의 다른점은 어떻게 될까요? </p>
<p>다음 코드를 봅시다.</p>
<pre><code class="language-c++">if(3 &amp; 1) printf(&quot;Bit says true.\n&quot;);
if(3 &amp;&amp; 1) printf(&quot;Logic says true.\n&quot;);
</code></pre>
<p><code>3 &amp; 1</code>을 계산하면 0이 나온다는 것을 어렵게 알 수 있어 첫번째 if문은실행이 되지 않습니다. 그러나 두번째 if문은 0이 아닌 두 값을 논리 AND연산을 하였기 때문에 참이 됩니다. 따라서 두번째 if문만 실행됩니다.</p>
<p>정리하자면 논리 AND는 <strong>0이면 false, 그 이외의 값이라면 true로 판단하여 연산을 진행하지만,</strong> 비트 AND는 __각 비트마다 0, 1로 연산을 진행한다는 점__을 염두에 두어야 합니다. 이는 논리연산과 비트연산의 중요한 차이점이니 꼭 짚고 넘어갑시다.</p>
<h2><a class="header" href="#bit-or" id="bit-or">3. BIT OR</a></h2>
<p>비트 OR연산자는 같은자리의 Bit를 비교하여 둘다 0이면 그 자리에 0을, 둘 중 하나라도 0이 아니면 1을 계산 결과로 내놓아 하나의 수를 만듭니다. 예를 들어 다음 코드를 보면</p>
<pre><code class="language-c++">printf(&quot;%d\n&quot;, 23 | 9); //31
printf(&quot;%d&quot;, 2 | 1); //3
printf(&quot;%d\n&quot;, 31 | 31); //31
</code></pre>
<p>같은 연산을 할 수 있습니다</p>
<p>마찬가지로 맨 위의 식을 예로 들어본다면</p>
<img src="datastructure/intermediate/bitoperator//Users/retr0/Desktop/iamcoder-wiki.github.io/src/datastructure/intermediate/bitmask/bitmask2.png" width = 200 >
<p>와 같이 됩니다.</p>
<p>논리 OR는 마찬가지로 0이면 false, 그 이외에는 전부 true를 기준으로 연산을 진행합니다. 다음 코드를 봅시다.</p>
<pre><code class="language-c++">if(1 | 0 == true) printf(&quot;Bit is true.\n&quot;); //true

if(1230 || 0 == true) printf(&quot;Logic is true.\n&quot;); //true
</code></pre>
<h2><a class="header" href="#bit-xor" id="bit-xor">4. BIT XOR</a></h2>
<p>비트 XOR연산자는 같은자리의 Bit를 비교하여 그 비트가 서로 같다면 그 자리에 0을, 다르다면 1을 계산 결과로 내놓아 하나의 수를 만듭니다. 예를 들어</p>
<pre><code class="language-c++">printf(&quot;%d\n&quot;, 23 ^ 9); //30
printf(&quot;%d\n&quot;, 2 ^ 1); //3
printf(&quot;%d\n&quot;, 31 ^ 31); //0
</code></pre>
<p>를 만족합니다.</p>
<p>가장 위의 식을 또 예로 들어본다면</p>
<img src="datastructure/intermediate/bitoperator//Users/retr0/Desktop/iamcoder-wiki.github.io/src/datastructure/intermediate/bitmask/bitmask3.png" width = 200 >
<p>와 같이 됩니다.</p>
<p>여담으로, 제곱을 나타내는 기호라고 생각하면 안됩니다. 제곱을 구하는 함수는 따로 있습니다.</p>
<h2><a class="header" href="#bit-shift" id="bit-shift">5. BIT SHIFT</a></h2>
<p>비트 SHIFT 연산은 위의 연산과 성격이 좀 다릅니다. 위에 있는 연산들은 교환법칙이 성립했다면, 이 연산은 교환법칙이 성립할 수 없습니다. 이 연산은 첫 번째 숫자를 두 번째 숫자만큼 비트단위에서 왼쪽/오른쪽으로 미는 것입니다.</p>
<p>그럼 정확하게 민다는 것이 무슨 뜻일까요? 다음 코드를 봅시다.</p>
<pre><code class="language-c++">printf(&quot;%d\n&quot;, 20 &gt;&gt; 2); //5

printf(&quot;%d\n&quot;, -6 &gt;&gt; 2); //-1

printf(&quot;%d\n&quot;, 12 &lt;&lt; 3); //96
</code></pre>
<p>첫번째 예를 살펴봅시다. 20은 이진수로 \(10100_{(2)}\) 입니다. 이 수를 오른쪽으로 두번 shift하면 5, 즉 \(101_{(2)}\)이 된다는 것을 쉽게 알 수 있습니다.</p>
<p>그러면, RSHIFT 연산후, 가장 왼쪽 비트에 나오는 숫자는 무엇일까요? 다음 예를 살펴봅시다.</p>
<p>-6을 이진수로 표현한다면(32비트 정수 기준) \(1111 1111 1111 1111 1111 1111 1111 1010_{(2)}\)입니다. 만약 shift 후 왼쪽에 0이 채워진다면, 첫번째 연산은 그대로 5이지만, 이 연산은 음수가 양수로 바뀌면서 약 10억정도에 가까운 숫자가 만들어지게 됩니다. 그러나, 실제 계산해보면 이 연산의 결과는 -1이 나옵니다. 즉, <strong>RSHIFT연산 후 왼쪽에 채워지는 비트는 연산 전에 원래 있었던 비트를 채운다는</strong> 거죠. </p>
<p>LSHIFT 연산에 경우는 왼쪽으로 shift하면서 오른쪽에 0을 채웁니다. 여기서 눈여겨 볼 점은, 정수 N을 M번 shift 했을때, 계산 결과가 \(N \times 2^{M}\)으로 나온다는 것이죠. 그렇다면 RSHIFT는 어떨까요? 그 연산은 실행시켜보면 \(N\)을 \(2^{M}\)으로 나눈 몫이 나옵니다. 곧, SHIFT 연산은 <strong>어떤 숫자를 2의 거듭제곱만큼 곱하거나 나눈 결과값을 반환한다고 할 수 있습니다.</strong></p>
<h2><a class="header" href="#bit-not" id="bit-not">6. BIT NOT</a></h2>
<p>비트 NOT연산자는 위의 연산자들과는 달리 단항연산자입니다. 단항연산자란, 하나의 수에 적용되는, 사칙연산보다는 부호연산과 더 가깝다고 할 수 있는 연산자 입니다. 이 연산자가 어떤 수 앞에 붙는다면 그 수의 비트를 전부 반대로 바꿔줍니다. 다음 코드를 살펴봅시다.</p>
<pre><code class="language-c++">printf(&quot;%d&quot;, ~10); //-11
</code></pre>
<p>갑자기 NOT연산의 결과를 통해 부호가 바뀌어서 당황스러울 수 있습니다. 그러나 이건 매우 당연한 것입니다. 첫번째 비트는 부호를 결정하기 때문에 그 비트까지 바뀌어서 부호가 바뀐 것입니다.</p>
<p>이 NOT연산은 특징이 있습니다. <code>~N</code>은 항상 <code>-N-1</code>이 됩니다. 이 결과는 비트 반전하여 계산하면 쉽게 알 수 있는데, <strong>이 비트 NOT연산을 한 수를 그 수의 보수라고 합니다.</strong></p>

                    </main>
                </div>
            </div>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
