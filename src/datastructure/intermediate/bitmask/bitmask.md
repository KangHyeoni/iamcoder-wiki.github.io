# Bitmask

## 소개

비트 연산자란, 각 수의 비트로(즉, 0과 1로) 연산을 진행하는 연산자입니다. 비트 연산자는 다음과 같이 있습니다.

* 비트 AND(&)
* 비트 OR(|)
* 비트 XOR(^)
* 비트 LSHIFT(<<), RSHIFT(>>)
* 비트 NOT(~)

비트 연산자를 사용하면 좋은 점이 무엇일까요? 그 이유는 연산속도가 빨라지기 때문입니다. 비트연산은 일반 사칙연산 연산자와는 달리 연산속도가 빨라 시간단축에 용이할 수 있습니다. 시간단축은 알고리즘 문제를 풀때 매우 중요한 요소라는 것은 독자 여러분들도 잘 알고 있을 것입니다.

## BIT AND

비트 AND연산자는 같은자리의 Bit를 비교하여 둘다 1이면 그 자리에 1을, 둘 중 하나라도 1이 아니면 0을 계산 결과로 내놓아 하나의 수를 만듭니다. Bit 연산이므로 2진수를 기준으로 연산하며, 일반 사칙연산보다 그 속도가 빠릅니다.

예를 들어 다음 코드를 보면

``` c++
printf("%d\n", 23 & 9); //1
printf("%d\n", 22 & 11); //2
printf("%d\n", 31 & 31); //31
```

같은 연산을 할 수 있습니다.

맨 위의 식을 예로 들어본다면 23은 이진수로 \\(10111_{(2)}\\)이고 9는 이진수로 \\(1001_{(2)}\\)이기 때문에 \\(&\\)연산을 취해준다면

<img src="./bitmask1.png" width = 200 >

와 같이 됩니다.

그렇다면 논리 AND와의 다른점은 어떻게 될까요? 

다음 코드를 봅시다.

``` c++
if(3 & 1) printf("Bit says true.\n");
if(3 && 1) printf("Logic says true.\n");
```

`3 & 1`을 계산하면 0이 나온다는 것을 어렵게 알 수 있어 첫번째 if문은실행이 되지 않습니다. 그러나 두번째 if문은 0이 아닌 두 값을 논리 AND연산을 하였기 때문에 참이 됩니다. 따라서 두번째 if문만 실행됩니다.

정리하자면 논리 AND는 __0이면 false, 그 이외의 값이라면 true로 판단하여 연산을 진행하지만,__ 비트 AND는 __각 비트마다 0, 1로 연산을 진행한다는 점__을 염두에 두어야 합니다. 이는 논리연산과 비트연산의 중요한 차이점이니 꼭 짚고 넘어갑시다.

## BIT 

